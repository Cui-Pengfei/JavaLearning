package cpf.learn.oop.poly;

/**
 * 多态的学习：
 *     【我的理解】适应java的"开闭原则"，具体方式是"里氏替换原则"，凡是父类可以出现的地方，
 *               子类一定可以出现，这样便实现了【对扩展开放，对修改关闭】
 *     【事实上】在对象的应用时，父类可以出现的地方，子类一定也可以出现，
 *              但是在对象的实例化时，子类对象可以由父类引用指向，这叫做向上转型，
 *                                父类对象不可以由子类引用指向，会报类型传递错误....
 *
 *  1.基本介绍
 *      方法或对象具有多种形态，是面向对象的第三大特征，多态是建立在封装和继承之上的...
 *
 *  2.具体表现
 *      2.1 方法多态
 *          重载 体现 同名方法 不同参数列表 的多种形态；
 *          重写 体现 同名方法 不同对象 的多种形态
 *      2.2 对象多态(是多态的核心)
 *          2.2.1 一个对象的编译类型和运行类型可以不一致，不一致时，运行类型必须是编译类型的子类
 *          2.2.2 编译类型在定义对象时，就确定了，不能改变
 *          2.2.3 运行类型可以改变
 *          2.2.4 编译类型看 = 左边，运行类型看 = 右
 *
 *  3.对象多态的细节
 *      3.1 多态的前提是，两个对象（类）存在继承关系
 *      3.2 多态的向上转型
 *          3.2.1 本质是，父类的引用指向子类的对象
 *          3.2.2 语法： 父类 引用名 = new 子类();
 *          3.2.3 特点：>编译类型在左边，运行类型在右边
 *                     >可以调用父类中的所有成员(需遵循访问权限)
 *                     >不能调用子类的特有成员
 *                     >具体运行效果，看子类的具体实现
 *           向上转型理解：父类有自己的成员;子类继承了父类所有成员，且有自己的个性;
 *                       子类向父类转型，意思是该引用仅使用子类中继承自父类的成员，父类是容器，子类填内容...
 *                       引用的编译类型是父类，自然只能访问父类中有的成员...能不能调用取决于编译器...
 *                       但是由于运行时是子类对象，具体实现还是看子类...
 *            口诀：编译的时候，从父类往下查找成员;
 *                 执行的时候，从子类网上查找成员;
 *
 *       3.3 多态的向下转型
 *           3.3.1 语法:子类 引用名 = (子类)父类引用;
 *           3.3.2 只能强制转化父类的引用，不能强制转化父类的对象...
 *           3.3.3 可转换的父类引用必须一开始就指向要转化的目标类型的对象，否则运行时会报错...
 *           3.3.4 转型成功后，对象可调用子类的所有成员
 *
 *   4.多态注意事项（见Notice.java）
 *       4.1 属性没有重写重写之说，编译类型是哪个类，就输出对应类的属性
 *
 *           
 *
 */
public class PolyIntro{
	public static void main(String[] args){
//2.多态的体现
		Master master = new Master("崔鹏飞");
		Dog dog = new Dog("旺财");
		Bone bone = new Bone("骨头");
		master.feed(dog,bone);

	//2.2 对象的多态
		Food food = new FishMeat("鱼肉");//定义对象时，编译类型和运行类型不一致
		food = new Bone("骨头");//运行类型还可以改变
		//food = new Dog();//运行类型的不一致是有限度的，必须是编译类型的子类
		//Bone bone1 = new Food();//父类运行不允许赋值给子类编译
		System.out.println(food.name);

//3.对象多态的细节
		Cat cat = new Cat("猫");//编译类型 = 运行类型 = Cat
		System.out.println(cat.name);
		cat.miaow();//可以访问到Cat类的特有方法

	//3.2 多态的向上转型
		Animal catUpAnimal = new Cat("猫向上转型动物");//编译类型 = Animal 运行类型 = Cat
		System.out.println(catUpAnimal.name);
		//不可以访问到Cat类中的特有方法...
		//catUpAnimal.miaow(); //报错：Cannot resolve method 'miaow' in 'Animal'

	//3.3 多态的向下转型
		//3.3.1 向上转型后的引用，可以再向下转型
		Cat upDownCat = (Cat)catUpAnimal;
		upDownCat.miaow();//向下转型后，容器变大，便可以使用Cat特有的成员了

		//3.3.3 本身就是父类的编译类型和运行类型，是不可以向下转型的
		Animal animal = new Animal();
		//Cat animalDownCat = (Cat)animal;  //编译可以通过，但是运行会报类型转换错误....
		//animalDownCat.miaow();


	}//end main
}//end public class
